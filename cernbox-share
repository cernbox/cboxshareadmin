#!/usr/bin/env python2
# -*- python -*-
#
# The CERNBox Project.
#
# Author: 
# License: AGPL
#
#$Id: $
#
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Perform internal setup of the environment.
# This is a Copy/Paste logic which must stay in THIS file
def standardSetup():
   import sys, os.path
   # insert the path to cernafs based on the relative position of this scrip inside the service directory tree
   exeDir = os.path.abspath(os.path.normpath(os.path.dirname(sys.argv[0])))
   pythonDir = os.path.join(exeDir, 'python' )
   sys.path.insert(0, pythonDir)
   import cernbox_utils.setup
   cernbox_utils.setup.standardSetup(sys.argv[0]) # execute a setup hook

standardSetup()
del standardSetup
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

config = None
logger = None

args = None

eos = None # EOS interface instance
db = None # DB interface instance

import cernbox_utils

def print_json(obj):
      if args.json:
         import json
         print json.dumps(obj,ensure_ascii=False) # allows unicode characters from eos output

def print_json_error(msg):
      print_json({"error" : str(msg)})


import os, os.path, sys
import subprocess

def main():
   global config,logger
   import cernbox_utils.script
   from cernbox_utils.eos import is_special_folder

   parser=cernbox_utils.script.arg_parser(description='Manipulate regular shares to users and egroups. ')
   subparser = parser.add_subparsers(title='command',dest='cmd')

   subcmd = subparser.add_parser('add', help="add a share to the system")
   #subcmd.add_argument("--force",default=False,action='store_true', help="do not perform consistency checks")
   subcmd.add_argument("path", help="path on storage")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("sharee", help="share with u:USER or egroup:GROUP")
   subcmd.add_argument("acl", help="access rights: r (read), rw (read-write)")

   subcmd = subparser.add_parser('remove', help="remove share from the system")
   #subcmd.add_argument("--force",default=False,action='store_true', help="do not perform consistency checks")
   #subcmd.add_argument("--nodb", default=False, action='store_true', help="do not modify the database and act on the storage ACLs only (check if the db entry does not exist)")
   subcmd.add_argument("path", help="path on storage")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("sharee", help="share with u:USER or egroup:GROUP")

   subcmd = subparser.add_parser('list-shared-by', help="list all shares created by the user")
   subcmd.add_argument("user", help="specify owner")
   subcmd.add_argument('--include-broken', default=False, action='store_true', help="include deleted or broken shares in he output")
   subcmd.add_argument("--flat-list", default=False, action='store_true', help="flat listing with raw DB values")   

   subcmd = subparser.add_parser('list-shared-with', help="list all shares given to the user")
   subcmd.add_argument("user", help="specify sharee")
   subcmd.add_argument('--include-broken', default=False, action='store_true', help="include deleted or broken shares in he output")
   subcmd.add_argument("--flat-list", default=False, action='store_true', help="flat listing with raw DB values")   

   subcmd = subparser.add_parser('acl_update', help="update the sharing ACL for a path and all subdirectories")
   subcmd.add_argument("pathspec", help="path or inode:n")
   #subcmd.add_argument("owner", help="owner of the share")

   subcmd = subparser.add_parser('summary', help="provide overview of shares per user or for all users")
   subcmd.add_argument("shares_owner", help="'-' to check all users in the system")
   subcmd.add_argument("--sort-by", default="all", action='store', help="sort output by the number of: 'all' shares, 'link' shares, 'regular' shares ")   

   subcmd = subparser.add_parser('verify', help="verify consistency of shares owned by the given user")
   subcmd.add_argument("--fix", default=False, action='store_true', help="fix any sharing inconsistencies in the storage and in the database")
   subcmd.add_argument("--fix-all-perms", default=False, action='store_true', help="fix all permisions (even if different and potentially overriding manualy set permissions)")
   subcmd.add_argument("--deep-fs-check", default=False, action='store_true', help="check the entire filesystem of the share_owner to misconfigured ACLs also in non-shared folders")
   subcmd.add_argument("--homedir", default="", action='store', help="override home directory (e.g. to check project spaces), if not set then it defaults to user home directory of shares_owner")
   subcmd.add_argument("--logdir",default="",action="store",help="log directory")
   subcmd.add_argument("shares_owner", help="'-' to check all users in the system")

   subcmd = subparser.add_parser('remove-orphan-xbits', help="remove xbits which were set in the initial implementation in the parent ACLs")
   subcmd.add_argument("--fix", default=False, action='store_true', help="fix it")
   subcmd.add_argument("--logdir",default="",action="store",help="log directory")
   subcmd.add_argument("path", help="top of the tree to check")

   subcmd = subparser.add_parser('show-other-acls', help="show all directories which have an acl which does not contain name (useful to see which directories are open besides the owner)")
   subcmd.add_argument("--ignore-special-directories", default=False, action='store_true', help="ignore special system directories (%s)"%is_special_folder.__doc__)
   subcmd.add_argument("path", help="top of the tree to check")
   subcmd.add_argument("name", help="name in ACL")
   
   global args
   args = parser.parse_args()

   config = cernbox_utils.script.configure(args.config)

   logger = cernbox_utils.script.getLogger(level=args.loglevel)

   logger.info("Using  DB: %s",config['dbhost'])
   logger.info("Using EOS: %s",config['eos_mgm_url'])

   global eos,db
   import cernbox_utils.db, cernbox_utils.eos
   db = cernbox_utils.db.ShareDB()
   eos = cernbox_utils.eos.EOS(config['eos_mgm_url'])
   eos.role=(0,0)

   #unit_test_swanprj()

   import cernbox_utils.sharing

   if args.cmd == "acl_update":
      import cernbox_utils.cmd_share_admin
      cernbox_utils.cmd_share_admin.acl_update(args,config,eos,db)

   if args.cmd == "remove":

      try:
         print_json(cmd_remove(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "add":

      try:
         print_json(cmd_add(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "list-shared-by":

      try:
         print_json(cmd_list_shares(args,'owner'))
      except CmdError:
         sys.exit(2)

   if args.cmd == "list-shared-with":

      try:
         print_json(cmd_list_shares(args,'sharee'))
      except CmdError:
         sys.exit(2)


   if args.cmd == "show-other-acls":
      import cernbox_utils.cmd_share_admin
      cernbox_utils.cmd_share_admin.show_other_acl(args,config,eos,db)

   if args.cmd == "remove-orphan-xbits":
      import cernbox_utils.cmd_share_admin

      cernbox_utils.cmd_share_admin.remove_orphan_xbits(args,config,eos,db)
      

   if args.cmd == "summary":
      import cernbox_utils.cmd_share_admin

      cernbox_utils.cmd_share_admin.summary(args,config,eos,db)

   if args.cmd == "verify":
      import cernbox_utils.cmd_share_admin

      cernbox_utils.cmd_share_admin.verify(args,config,eos,db)

   
class CmdError(Exception):
   pass


def cmd_remove(args):

      share_with_entity,share_with_who = parse_sharee(args.sharee)

      path = parse_path(args.path)

      f = check_share_target(path, args.owner)

      shares=db.get_share(sharee=share_with_who,owner=args.owner,fid=f.ino)

      if len(shares)>1:
         msg="Multiple shares exist, share ids %s"%[s.id for s in shares]
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)

      if len(shares)==0:
         msg="Share from user %s to %s does not exist at path %s"%(args.owner,share_with_who,f.file)
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)
       
      #print 'would delete',shares[0].id
      db.delete_share(shares[0].id)

      try:
         # modify storage ACL      
         cernbox_utils.sharing.update_acls(f.ino,eos,db,args.owner)
      except Exception,x:
         logger.critical("Something went pretty wrong... %s %s",hash(x),x)
         print_json_error("Critical error %s"%hash(x))
         #rollback the insert?
         raise
         sys.exit(2)


def cmd_add(args):

   return _cmd_add(args.owner,args.path,args.sharee,args.acl)

def _cmd_add(owner,path,sharee,acl,storage_acl_update=True):

      check_share_not_self(owner,sharee)

      share_with_entity,share_with_who = parse_sharee(sharee)

      path = parse_path(path)
      
      f = check_share_target(path, owner)

      # ... continue from common code above

      ACL = {'r':'read','rw':'read-write'}
      ENTITY = {'u':'user','egroup':'egroup'}

      logger.info("Add %s share for %s %s to tree %s",ACL[acl],ENTITY[share_with_entity],share_with_who,path)
 
      # FIXME: do not use pound for this anymore (#): breaks HTTP standard and client browsers...
      file_target="/%s (#%d)" %(os.path.basename(os.path.normpath(f.file)),int(f.ino))

      # FIXME: poor's man solution: owncloud does not have constraints in the oc_share table
      # try to insert share entry, bailout if already exists...

      shares=db.get_share(sharee=share_with_who,owner=owner,fid=f.ino)

      if shares:
         msg="Share already exists, share id %d"%shares[0].id
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)
      else:
         db.insert_folder_share(owner,share_with_who,int(f.ino),file_target,cernbox_utils.sharing.crud2db(acl))

      try:
         # modify storage ACL
         if storage_acl_update:
            cernbox_utils.sharing.update_acls(f.ino,eos,db,owner,dryrun=False)
      except Exception,x:
         logger.critical("Something went pretty wrong... %s %s",hash(x),x)
         print_json_error("Critical error %s"%hash(x))
         #rollback the insert?
         raise
         sys.exit(2)

def cmd_list_shares(args,role):

   import cernbox_utils.sharing 
   retobj = cernbox_utils.sharing.list_shares(args.user,role,None,False,False,db,eos)
   return {'shares':retobj}

def _cmd_list_shares(args,fid=None):
   from cernbox_utils import db,eos,sharing

   if not args.user.strip():
      logger.critical("Must provide a user name!")
      raise CmdError()

   db = db.ShareDB()
   eos = eos.EOS(config['eos_mgm_url'])
   eos.role=(0,0)

   if args.cmd == "list-shared-by":
      shares=db.get_share(owner=args.user,fid=fid)
   else:
      shares=db.get_share(sharee=args.user,fid=fid)   

   import datetime
   def dtisoformat(x):
      if x:
         return x.isoformat()
      else:
         return ""

   if args.flat_list:
      cnt=0
      retobj = {}
      for s in shares:
         logger.debug("Processing share: %s %s->%s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(str(s.file_target)))

         try:
            share_path = eos.fileinfo("inode:"+s.item_source).file
         except  subprocess.CalledProcessError,x:
            if x.returncode == 2:
               # eos entry does not exist
               logger.warning("DANGLING_SHARE id=%d owner=%s sharee=%s target='%s' inode=%s",s.id,s.uid_owner,s.share_with,s.file_target,s.item_source)
               share_path=None


         if share_path or args.include_broken:
            retobj[s.id] = {'uid_owner':s.uid_owner,'share_id':s.id, 'share_with':s.share_with,'type':s.share_type,'target_inode':s.item_source,'target_name':s.file_target, 'permissions':s.permissions, 'created' : datetime.datetime.fromtimestamp(s.stime).isoformat(), 'expires' : dtisoformat(s.expiration), 'token':s.token, 'target_path':share_path }


      return retobj
   else:
      retobj = []
      nodes = sharing.collapse_into_nodes(shares)
      for target_id in nodes:
         try:
            f = eos.fileinfo("inode:"+target_id)
            target_path,target_size=f.file,f.treesize
         except  subprocess.CalledProcessError,x:
            if x.returncode == 2:
               # eos entry does not exist
               logger.warning("DANGLING_SHARE inode=%s",target_id)
               target_path,target_size=None,0


         if target_path or args.include_broken:
            retobj.append({'path':target_path, 'inode':target_id, 'size':target_size, 'shared_by':nodes[target_id].owner, 'shared_with' : []})
            for s in nodes[target_id].shares:
               acl = sharing.share2acl(s)
               retobj[-1]['shared_with'].append({'entity':acl.entity,'name':acl.name,'permissions':sharing.db2crud(s.permissions),'created':datetime.datetime.fromtimestamp(s.stime).isoformat()})

      return retobj

if __name__ == "__main__":
   sys.exit(main())
