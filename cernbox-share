#!/usr/bin/env python2
# -*- python -*-
#
# The CERNBox Project.
#
# Author: 
# License: AGPL
#
#$Id: $
#
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Perform internal setup of the environment.
# This is a Copy/Paste logic which must stay in THIS file
def standardSetup():
   import sys, os.path
   # insert the path to cernafs based on the relative position of this scrip inside the service directory tree
   exeDir = os.path.abspath(os.path.normpath(os.path.dirname(sys.argv[0])))
   pythonDir = os.path.join(exeDir, 'python' )
   sys.path.insert(0, pythonDir)
   import cernbox_utils.setup
   cernbox_utils.setup.standardSetup(sys.argv[0]) # execute a setup hook

standardSetup()
del standardSetup
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

config = None
logger = None

args = None

eos = None # EOS interface instance
db = None # DB interface instance

import cernbox_utils

def print_json(obj):
      if args.json:
         import json
         print json.dumps(obj,ensure_ascii=False) # allows unicode characters from eos output

def print_json_error(msg):
      print_json({"error" : str(msg)})


import os, os.path, sys
import subprocess

def main():
   global config,logger
   import cernbox_utils.script
   from cernbox_utils.eos import is_special_folder

   parser=cernbox_utils.script.arg_parser(description='Manipulate regular shares to users and egroups. ')
   subparser = parser.add_subparsers(title='command',dest='cmd')

   subcmd = subparser.add_parser('add', help="add a share to the system")
   #subcmd.add_argument("--force",default=False,action='store_true', help="do not perform consistency checks")
   subcmd.add_argument("path", help="path on storage")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("sharee", help="share with u:USER or egroup:GROUP")
   subcmd.add_argument("acl", help="access rights: r (read), rw (read-write)")

   subcmd = subparser.add_parser('remove', help="remove share from the system")
   #subcmd.add_argument("--force",default=False,action='store_true', help="do not perform consistency checks")
   #subcmd.add_argument("--nodb", default=False, action='store_true', help="do not modify the database and act on the storage ACLs only (check if the db entry does not exist)")
   subcmd.add_argument("path", help="path on storage")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("sharee", help="share with u:USER or egroup:GROUP")

   subcmd = subparser.add_parser('list-shared-by', help="list all shares created by the user")
   subcmd.add_argument("user", help="specify owner")
   subcmd.add_argument('--include-broken', default=False, action='store_true', help="include deleted or broken shares in he output")
   subcmd.add_argument("--flat-list", default=False, action='store_true', help="flat listing with raw DB values")   

   subcmd = subparser.add_parser('list-shared-with', help="list all shares given to the user")
   subcmd.add_argument("user", help="specify sharee")
   subcmd.add_argument('--include-broken', default=False, action='store_true', help="include deleted or broken shares in he output")
   subcmd.add_argument("--flat-list", default=False, action='store_true', help="flat listing with raw DB values")   

   subcmd = subparser.add_parser('swan-list-projects-shared-by', help="list all SWAN projects shared by the user")
   subcmd.add_argument("user", help="specify owner")
   subcmd.add_argument("--project", default=None, action='store', help="specify particular project to list")   

   subcmd = subparser.add_parser('swan-list-projects-shared-with', help="list all SWAN projects shared with the user")
   subcmd.add_argument("user", help="specify sharee")

   subcmd = subparser.add_parser('swan-update-project-share', help="update share for a SWAN project which will be shared to the specified sharees (and only to them)")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("project", help="project path")
   subcmd.add_argument("sharees", help="specify sharees",nargs='+')

   subcmd = subparser.add_parser('swan-delete-project-share', help="delete all shares for a SWAN project")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("project", help="project path")

   subcmd = subparser.add_parser('acl_update', help="update the sharing ACL for a path and all subdirectories")
   subcmd.add_argument("pathspec", help="path or inode:n")
   #subcmd.add_argument("owner", help="owner of the share")

   subcmd = subparser.add_parser('summary', help="provide overview of shares per user or for all users")
   subcmd.add_argument("shares_owner", help="'-' to check all users in the system")
   subcmd.add_argument("--sort-by", default="all", action='store', help="sort output by the number of: 'all' shares, 'link' shares, 'regular' shares ")   

   subcmd = subparser.add_parser('verify', help="verify consistency of shares owned by the given user")
   subcmd.add_argument("--fix", default=False, action='store_true', help="fix any sharing inconsistencies in the storage and in the database")
   subcmd.add_argument("--fix-all-perms", default=False, action='store_true', help="fix all permisions (even if different and potentially overriding manualy set permissions)")
   subcmd.add_argument("--deep-fs-check", default=False, action='store_true', help="check the entire filesystem of the share_owner to misconfigured ACLs also in non-shared folders")
   subcmd.add_argument("--homedir", default="", action='store', help="override home directory (e.g. to check project spaces), if not set then it defaults to user home directory of shares_owner")
   subcmd.add_argument("--logdir",default="",action="store",help="log directory")
   subcmd.add_argument("shares_owner", help="'-' to check all users in the system")

   subcmd = subparser.add_parser('remove-orphan-xbits', help="remove xbits which were set in the initial implementation in the parent ACLs")
   subcmd.add_argument("--fix", default=False, action='store_true', help="fix it")
   subcmd.add_argument("--logdir",default="",action="store",help="log directory")
   subcmd.add_argument("path", help="top of the tree to check")

   subcmd = subparser.add_parser('show-other-acls', help="show all directories which have an acl which does not contain name (useful to see which directories are open besides the owner)")
   subcmd.add_argument("--ignore-special-directories", default=False, action='store_true', help="ignore special system directories (%s)"%is_special_folder.__doc__)
   subcmd.add_argument("path", help="top of the tree to check")
   subcmd.add_argument("name", help="name in ACL")
   
   global args
   args = parser.parse_args()

   config = cernbox_utils.script.configure(args.config)

   logger = cernbox_utils.script.getLogger(level=args.loglevel)

   logger.info("Using  DB: %s",config['dbhost'])
   logger.info("Using EOS: %s",config['eos_mgm_url'])

   global eos,db
   import cernbox_utils.db, cernbox_utils.eos
   db = cernbox_utils.db.ShareDB()
   eos = cernbox_utils.eos.EOS(config['eos_mgm_url'])
   eos.role=(0,0)

   #unit_test_swanprj()

   import cernbox_utils.sharing

   if args.cmd == "acl_update":
      db = db.ShareDB()
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      import cernbox_utils.sharing

      if args.pathspec.startswith("inode:"):
         inode = args.pathspec[len("inode:"):]
      else:
         inode = eos.fileinfo(args.pathspec).ino

      cernbox_utils.sharing.update_acls(inode,eos,db,owner=None,dryrun=False)

   if args.cmd == "remove":

      try:
         print_json(cmd_remove(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "add":

      try:
         print_json(cmd_add(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "show-other-acls":
      #from cernbox_utils import eos
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      other_acl_cnt = 0
      empty_acl_cnt = 0
      special_dir_cnt = 0
      cnt = 0

      for f in eos.fileinfo_r(args.path,type="-d"):

         cnt += 1
      
         if is_special_folder(f.file):
            special_dir_cnt+=1
            if args.ignore_special_directories:
               continue

         try:
            eos_acls = eos.parse_sysacl(f.xattr['sys.acl'])
         except KeyError,x:
            empty_acl_cnt+=1 # no ACL at all

         for acl in eos_acls:
            if acl.name != args.name:
               other_acl_cnt+=1
               logger.info("%s %s",f.file,eos_acls)
               break
            
      logger.info("Scan completed. Found %d directories, %d with acls not containing %s, %d with empty acls, %d special dirs",cnt,other_acl_cnt,args.name,empty_acl_cnt,special_dir_cnt)

   if args.cmd == "remove-orphan-xbits":
      #from cernbox_utils import eos
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      logfn = ""

      if args.logdir:
         import logging
         fix_str = ""
         if args.fix: fix_str=".fix"
         logfn = os.path.join(args.logdir,os.path.normpath(args.path).replace(os.sep,"_")+fix_str+".log")
         fh = logging.FileHandler(logfn)
         fh.setFormatter(logging.Formatter("%(asctime)s %(message)s"))
         logger.addHandler(fh)

      cnt = 0
      fixed_cnt = 0

      for f in eos.fileinfo_r(args.path,type="-d"):
         cnt += 1
         try:
            eos_acls = eos.parse_sysacl(f.xattr['sys.acl'])
         except KeyError,x:
            continue # no ACL at all

         new_acls = []
         for acl in eos_acls:
            if not acl.bits == "x":
               new_acls.append(acl)

         #logger.info(" --- SCAN      --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(eos_acls))

         if new_acls != eos_acls:
            logger.info(" --- NEW_ACL   --- %s --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(new_acls),eos.dump_sysacl(eos_acls))
            eos.set_sysacl(f.file,eos.dump_sysacl(new_acls),dryrun=not args.fix)
            fixed_cnt += 1
         else:
            #logger.info(" --- NO_CHANGE --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(eos_acls))
            pass

      logger.info("Scanned %d directories, fixed %d directories, logfile: %s",cnt,fixed_cnt,logfn)

#            print f.file, "would set", eos_acls, "->", new_acls
            #if len(new_acls)>1: print "MUTLIPLE"
#
#         else:
#            print f.file, "no change",eos_acls

   if args.cmd in ["list-shared-by","list-shared-with"]:

      try:
         print_json(cmd_list_shares(args))
      except CmdError:
         sys.exit(2)


   if args.cmd in ["swan-list-projects-shared-by","swan-list-projects-shared-with"]:

      if args.cmd == "swan-list-projects-shared-with":
         args.project = None

      try:
         print_json(cmd_swan_list_projects(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "swan-update-project-share":

      try:
         print_json(cmd_swan_update_share(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "swan-delete-project-share":

      try:
         print_json(cmd_swan_delete_share(args))
      except CmdError:
         sys.exit(2)

   if args.cmd == "summary":

      from cernbox_utils import db,eos

      if not args.shares_owner.strip():
         logger.critical("Must provide a shares_owner or '-'")
         return

      if args.shares_owner == '-':
         args.shares_owner = ''


      db = db.ShareDB()

      shares=db.get_share(owner=args.shares_owner)

      owner_all_share_cnt = {}
      owner_link_share_cnt = {}
      owner_regular_share_cnt = {}

      for s in shares:
         try:
            if s.file_target is None:
               s.file_target = ''

            logger.debug("Processing share: %s %s->%s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(s.file_target))

            owner_all_share_cnt.setdefault(s.uid_owner,0)
            owner_link_share_cnt.setdefault(s.uid_owner,0)
            owner_regular_share_cnt.setdefault(s.uid_owner,0)

            owner_all_share_cnt[s.uid_owner] += 1

            if s.share_type == 3:
               owner_link_share_cnt[s.uid_owner] += 1
            else:
               owner_regular_share_cnt[s.uid_owner] += 1

         except Exception,x:
            logger.error("Problem with processing share id=%d : %s",s.id,repr(x))
            raise

      sort_by = owner_all_share_cnt


      if args.sort_by == 'regular':
         sort_by = owner_regular_share_cnt

      if args.sort_by == 'link':
         sort_by = owner_link_share_cnt

      index = len(owner_all_share_cnt)

      for u,cnt in sorted(sort_by.iteritems(), key=lambda (k,v): (v,k)):
         logger.info("Index #%4d Owner %10s has total of %4d shares: %4d regular shares, %4d link shares",index,u,owner_all_share_cnt[u],owner_regular_share_cnt[u],owner_link_share_cnt[u])
         index -= 1


   if args.cmd == "verify":
      import cernbox_utils.cmd_share_admin

      cernbox_utils.cmd_share_admin.verify(args,config,eos,db)



def more_permissions_than(acl_list, reference_acl_list):
   """Return all ACL entries from acl_list which give more permissions than specified by reference_acl_list.
   """

   acls=set(acl_list)
   refs=set(reference_acl_list)

   more = set()

   for acl in acls:
      if not acl in refs:
         pass
   
def parse_sharee(sharee):
    try:
       entity,who = sharee.split(":") # this may also raise ValueError
       if not entity in ['u','egroup']:
          raise ValueError()
    except ValueError:
       print >> sys.stderr, "ERROR: specify sharee '%s' in u:USER or egroup:GROUP format"%sharee
       sys.exit(2)
    return entity,who

def parse_path(path):
    if not path.startswith(config['eos_prefix']):
       print >> sys.stderr, "ERROR: path '%s' should start with '%s'"% (path,config['eos_prefix'])
       sys.exit(2)
    return path

def parse_swan_project(swanprj):
   if not is_swanprj(swanprj):
      print >> sys.stderr, "ERROR: SWAN project name wrongly specified '%s'"% (swanprj)
      sys.exit(2)


def check_share_not_self(owner,sharee):
   entity,who = parse_sharee(sharee)

   if entity == 'u' and who == owner:
      print >> sys.stderr, "ERROR: cannot share with self '%s'"% owner
      sys.exit(2)      

class CmdError(Exception):
   pass


def get_swan_project_fileinfo(owner,swan_project):

      p = swanprj2path(owner,swan_project)

      if not p:
         print_json_error("Project name misformatted: %s"%(swan_project))
         sys.exit(2) # TODO: FIX RC => 400 Bad Request

      try:
         return check_share_target(p,owner)
      except  subprocess.CalledProcessError,x:
         if x.returncode == 2:
            print_json_error("Project not found: %s owner %s"%(swan_project,owner))
            sys.exit(2) 
         else:
            raise

def cmd_swan_update_share(args):
   parse_swan_project(args.project)
   return _cmd_swan_update_share(args.project, args.owner, args.sharees)

def cmd_swan_delete_share(args):
   parse_swan_project(args.project)
   return _cmd_swan_update_share(args.project, args.owner, [])

def _cmd_swan_update_share(swan_project, owner, sharees):

   for sharee in sharees:
      check_share_not_self(owner,sharee)

   f = get_swan_project_fileinfo(owner, swan_project)

   shares=db.get_share(owner=owner,fid=f.ino)

   sharees_requested = [ parse_sharee(x)[1] for x in sharees ]

   db_update_cnt = 0

   for s in shares:
      if s.share_with not in sharees_requested:
         db.delete_share(s.id)
         db_update_cnt += 1

   sharees_existing = [ s.share_with for s in shares ]

   for sharee in sharees:
      if parse_sharee(sharee)[1] not in sharees_existing:
         _cmd_add(owner,f.file,sharee,"r",storage_acl_update=False)
         db_update_cnt += 1

   try:
      logger.info("Updated %d share entries",db_update_cnt)

      if db_update_cnt:
         # modify storage ACL      
         cernbox_utils.sharing.update_acls(f.ino,eos,db,args.owner,dryrun=False)

   except Exception,x:
      logger.critical("Something went pretty wrong... %s %s",hash(x),x)
      print_json_error("Critical error %s"%hash(x))
      #rollback the insert?
      raise
      sys.exit(2)

def cmd_remove(args):

      share_with_entity,share_with_who = parse_sharee(args.sharee)

      path = parse_path(args.path)

      f = check_share_target(path, args.owner)

      shares=db.get_share(sharee=share_with_who,owner=args.owner,fid=f.ino)

      if len(shares)>1:
         msg="Multiple shares exist, share ids %s"%[s.id for s in shares]
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)

      if len(shares)==0:
         msg="Share from user %s to %s does not exist at path %s"%(args.owner,share_with_who,f.file)
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)
       
      #print 'would delete',shares[0].id
      db.delete_share(shares[0].id)

      try:
         # modify storage ACL      
         cernbox_utils.sharing.update_acls(f.ino,eos,db,args.owner)
      except Exception,x:
         logger.critical("Something went pretty wrong... %s %s",hash(x),x)
         print_json_error("Critical error %s"%hash(x))
         #rollback the insert?
         raise
         sys.exit(2)


def cmd_add(args):

   return _cmd_add(args.owner,args.path,args.sharee,args.acl)

def _cmd_add(owner,path,sharee,acl,storage_acl_update=True):

      check_share_not_self(owner,sharee)

      share_with_entity,share_with_who = parse_sharee(sharee)

      path = parse_path(path)
      
      f = check_share_target(path, owner)

      # ... continue from common code above

      ACL = {'r':'read','rw':'read-write'}
      ENTITY = {'u':'user','egroup':'egroup'}

      logger.info("Add %s share for %s %s to tree %s",ACL[acl],ENTITY[share_with_entity],share_with_who,path)
 
      # FIXME: do not use pound for this anymore (#): breaks HTTP standard and client browsers...
      file_target="/%s (#%d)" %(os.path.basename(os.path.normpath(f.file)),int(f.ino))

      # FIXME: poor's man solution: owncloud does not have constraints in the oc_share table
      # try to insert share entry, bailout if already exists...

      shares=db.get_share(sharee=share_with_who,owner=owner,fid=f.ino)

      if shares:
         msg="Share already exists, share id %d"%shares[0].id
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)
      else:
         db.insert_folder_share(owner,share_with_who,int(f.ino),file_target,cernbox_utils.sharing.crud2db(acl))

      try:
         # modify storage ACL
         if storage_acl_update:
            cernbox_utils.sharing.update_acls(f.ino,eos,db,owner,dryrun=False)
      except Exception,x:
         logger.critical("Something went pretty wrong... %s %s",hash(x),x)
         print_json_error("Critical error %s"%hash(x))
         #rollback the insert?
         raise
         sys.exit(2)



def check_share_target(path,owner):

      # find the target

      try:
         f = eos.fileinfo(path)
      except subprocess.CalledProcessError,x:
         if 'error: cannot stat' in x.stderr:
            msg = "Not found: %s"%path
            logger.error(msg)
            print_json_error(msg)
            sys.exit(2)
         else:
            logger.error(repr(x.stderr))
            sys.exit(2)

      # make sure it is a folder, not a file
   
      if not f.is_dir():
         msg = "Authenticated shares not supported for individual files... %s"%f.file
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)

      # get the top level

      if os.path.normpath(f.file).startswith(os.path.join(config['eos_prefix'],owner[0],owner)):
         top_level = os.path.join(config['eos_prefix'],owner[0],owner)
      elif os.path.normpath(f.file).startswith(config['eos_project_prefix']):
         # check eligibility based on admin/writers egroup?
         print_json_error("NotImplemented")
         raise NotImplemented()
      else:
         msg="Cannot share outside of home and project directories"
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)         

      return f


def cmd_list_shares(args):

   retobj = _cmd_list_shares(args)

   return {'shares':retobj}
      

def cmd_swan_list_projects(args):
   
   args.include_broken = False
   args.flat_list = False
   args.cmd = args.cmd.replace("swan-list-projects-","list-")

   if args.project:
      parse_swan_project(args.project)
      f = get_swan_project_fileinfo(args.user,args.project)
      inode=f.ino
   else:
      inode = None

   retbuf = _cmd_list_shares(args,inode)

   retobj = []
   
   for x in retbuf:

      swanprj = path2swanprj(x['path'])

      if swanprj:
         x['project']=swanprj
         retobj.append(x)

   return {'shares':retobj}


# convert SWAN project name to EOS path and vice-versa

def is_swanprj(pname):
   p = os.path.split(os.path.normpath(pname))
   return len(p)==2 and p[0]=='SWAN_projects'

def swanprj2path(owner,pname):
   if not is_swanprj(pname):
      return None
   else:
      return os.path.join(config['eos_prefix'],owner[0],owner,pname)

def path2swanprj(path):
   if not path.startswith(config['eos_prefix']):
      return None

   p = os.path.normpath(path[len(config['eos_prefix']):])

   p = "/".join(p.split('/')[2:])

   if is_swanprj(p):
      return p
   else:
      return None

def unit_test_swanprj():

   print "--- UNIT TEST SWANPRJ: BEGIN"

   assert(os.path.normpath(config['eos_prefix']) == '/eos/scratch/user')

   print is_swanprj("SWAN_projects/X") # => True
   print is_swanprj("SWAN_projects/X/Y") # => False
   print is_swanprj("SWAN_projects/") # => False
   print is_swanprj("SWAN_projects") # => False
   print is_swanprj("X") # => False
   print is_swanprj("") # => False

   print swanprj2path('moscicki',"X") # => None
   print swanprj2path('moscicki',"SWAN_projects/X") # => /eos/scratch/user/m/moscicki/SWAN_projects/X

   print path2swanprj("/eos/scratch/user/m/moscicki/SWAN_projects/X") # => SWAN_projects/X

   print "--- UNIT TEST SWANPRJ: END"

def _cmd_list_shares(args,fid=None):
   from cernbox_utils import db,eos,sharing

   if not args.user.strip():
      logger.critical("Must provide a user name!")
      raise CmdError()

   db = db.ShareDB()
   eos = eos.EOS(config['eos_mgm_url'])
   eos.role=(0,0)

   if args.cmd == "list-shared-by":
      shares=db.get_share(owner=args.user,fid=fid)
   else:
      shares=db.get_share(sharee=args.user,fid=fid)   

   import datetime
   def dtisoformat(x):
      if x:
         return x.isoformat()
      else:
         return ""

   if args.flat_list:
      cnt=0
      retobj = {}
      for s in shares:
         logger.debug("Processing share: %s %s->%s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(str(s.file_target)))

         try:
            share_path = eos.fileinfo("inode:"+s.item_source).file
         except  subprocess.CalledProcessError,x:
            if x.returncode == 2:
               # eos entry does not exist
               logger.warning("DANGLING_SHARE id=%d owner=%s sharee=%s target='%s' inode=%s",s.id,s.uid_owner,s.share_with,s.file_target,s.item_source)
               share_path=None


         if share_path or args.include_broken:
            retobj[s.id] = {'uid_owner':s.uid_owner,'share_id':s.id, 'share_with':s.share_with,'type':s.share_type,'target_inode':s.item_source,'target_name':s.file_target, 'permissions':s.permissions, 'created' : datetime.datetime.fromtimestamp(s.stime).isoformat(), 'expires' : dtisoformat(s.expiration), 'token':s.token, 'target_path':share_path }


      return retobj
   else:
      retobj = []
      nodes = sharing.collapse_into_nodes(shares)
      for target_id in nodes:
         try:
            f = eos.fileinfo("inode:"+target_id)
            target_path,target_size=f.file,f.treesize
         except  subprocess.CalledProcessError,x:
            if x.returncode == 2:
               # eos entry does not exist
               logger.warning("DANGLING_SHARE inode=%s",target_id)
               target_path,target_size=None,0


         if target_path or args.include_broken:
            retobj.append({'path':target_path, 'inode':target_id, 'size':target_size, 'shared_by':nodes[target_id].owner, 'shared_with' : []})
            for s in nodes[target_id].shares:
               acl = sharing.share2acl(s)
               retobj[-1]['shared_with'].append({'entity':acl.entity,'name':acl.name,'permissions':sharing.db2crud(s.permissions),'created':datetime.datetime.fromtimestamp(s.stime).isoformat()})

      return retobj

if __name__ == "__main__":
   sys.exit(main())
