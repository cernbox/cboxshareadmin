#!/usr/bin/env python2
# -*- python -*-
#
# The CERNBox Project.
#
# Author: 
# License: AGPL
#
#$Id: $
#
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Perform internal setup of the environment.
# This is a Copy/Paste logic which must stay in THIS file
def standardSetup():
   import sys, os.path
   # insert the path to cernafs based on the relative position of this scrip inside the service directory tree
   exeDir = os.path.abspath(os.path.normpath(os.path.dirname(sys.argv[0])))
   pythonDir = os.path.join(exeDir, 'python' )
   sys.path.insert(0, pythonDir)
   import cernbox_utils.setup
   cernbox_utils.setup.standardSetup(sys.argv[0]) # execute a setup hook

standardSetup()
del standardSetup
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

config = None

import os, os.path, sys
import subprocess

def quote(s):
   if not s:
      s=''
   return "'"+s+"'"

def main():
   global config
   import cernbox_utils.script

   parser=cernbox_utils.script.arg_parser(description='Manipulate regular shares to users and egroups. ')
   subparser = parser.add_subparsers(title='command',dest='cmd')

   subcmd = subparser.add_parser('add', help="add a share to the system")
   #subcmd.add_argument("--force",default=False,action='store_true', help="do not perform consistency checks")
   subcmd.add_argument("path", help="path on storage")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("sharee", help="share with u:USER or egroup:GROUP")
   subcmd.add_argument("acl", help="access rights: r (read), rw (read-write)")

   subcmd = subparser.add_parser('remove', help="remove share from the system")
   #subcmd.add_argument("--force",default=False,action='store_true', help="do not perform consistency checks")
   #subcmd.add_argument("--nodb", default=False, action='store_true', help="do not modify the database and act on the storage ACLs only (check if the db entry does not exist)")
   subcmd.add_argument("path", help="path on storage")
   subcmd.add_argument("owner", help="share owner")
   subcmd.add_argument("sharee", help="share with u:USER or egroup:GROUP")

   subcmd = subparser.add_parser('list-shared-by', help="list all shares created by the user")
   subcmd.add_argument("user", help="specify owner")
   subcmd.add_argument('--include-broken', default=False, action='store_true', help="include deleted or broken shares in he output")
   #subcmd.add_argument("--tree", default=False, action='store_true', help="enable tree-like view")   

   subcmd = subparser.add_parser('list-shared-with', help="list all shares given to the user")
   subcmd.add_argument("user", help="specify sharee")
   subcmd.add_argument('--include-broken', default=False, action='store_true', help="include deleted or broken shares in he output")
   #subcmd.add_argument("--tree", default=False, action='store_true', help="enable tree-like view")   

   subcmd = subparser.add_parser('acl_update', help="update the sharing ACL for a path and all subdirectories")
   subcmd.add_argument("pathspec", help="path or inode:n")
   #subcmd.add_argument("owner", help="owner of the share")

   subcmd = subparser.add_parser('summary', help="provide overview of shares per user or for all users")
   subcmd.add_argument("shares_owner", help="'-' to check all users in the system")
   subcmd.add_argument("--sort-by", default="all", action='store', help="sort output by the number of: 'all' shares, 'link' shares, 'regular' shares ")   

   subcmd = subparser.add_parser('verify', help="verify consistency of shares owned by the given user")
   subcmd.add_argument("--fix", default=False, action='store_true', help="fix any sharing inconsistencies in the storage and in the database")
   subcmd.add_argument("--fix-all-perms", default=False, action='store_true', help="fix all permisions (even if different and potentially overriding manualy set permissions)")
   subcmd.add_argument("--deep-fs-check", default=False, action='store_true', help="check the entire filesystem of the share_owner to misconfigured ACLs also in non-shared folders")
   subcmd.add_argument("--homedir", default="", action='store', help="override home directory (e.g. to check project spaces), if not set then it defaults to user home directory of shares_owner")
   subcmd.add_argument("--logdir",default="",action="store",help="log directory")
   subcmd.add_argument("shares_owner", help="'-' to check all users in the system")

   subcmd = subparser.add_parser('remove-orphan-xbits', help="remove xbits which were set in the initial implementation in the parent ACLs")
   subcmd.add_argument("--fix", default=False, action='store_true', help="fix it")
   subcmd.add_argument("--logdir",default="",action="store",help="log directory")
   subcmd.add_argument("path", help="top of the tree to check")

   subcmd = subparser.add_parser('show-other-acls', help="show all directories which have an acl which does not contain name (useful to see which directories are open besides the owner)")
   subcmd.add_argument("--ignore-special-directories", default=False, action='store_true', help="ignore special system directories (%s)"%is_special_folder.__doc__)
   subcmd.add_argument("path", help="top of the tree to check")
   subcmd.add_argument("name", help="name in ACL")
   
   args = parser.parse_args()

   config = cernbox_utils.script.configure(args.config)

   logger = cernbox_utils.script.getLogger(level=args.loglevel)

   logger.info("Using  DB: %s",config['dbhost'])
   logger.info("Using EOS: %s",config['eos_mgm_url'])

   from cernbox_utils import db,eos

   import cernbox_utils.sharing

   def print_json(obj):
      if args.json:
         import json
         print json.dumps(obj,ensure_ascii=False) # allows unicode characters from eos output

   def print_json_error(msg):
      print_json({"error" : str(msg)})


   if args.cmd == "acl_update":
      db = db.ShareDB()
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      import cernbox_utils.sharing

      if args.pathspec.startswith("inode:"):
         fid = args.pathspec[len("inode:"):]
      else:
         fid = eos.fileinfo(args.pathspec).fid

      cernbox_utils.sharing.update_acls(fid,eos,db,owner=None,dryrun=False)

   if args.cmd in ["remove","add"]:

      # common code for add and remove

      share_with_entity,share_with_who = parse_sharee(args.sharee)

      path = parse_path(args.path)

      from cernbox_utils import db
      db = db.ShareDB()

      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      # find the target

      try:
         f = eos.fileinfo(args.path)
      except subprocess.CalledProcessError,x:
         if 'error: cannot stat' in x.stderr:
            msg = "Not found: %s"%args.path
            logger.error(msg)
            print_json_error(msg)
            sys.exit(2)
         else:
            logger.error(repr(x.stderr))
            sys.exit(2)

      # make sure it is a folder, not a file
   
      if not f.is_dir():
         msg = "Authenticated shares not supported for individual files... %s"%f.file
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)

      # get the top level

      if os.path.normpath(f.file).startswith(os.path.join(config['eos_prefix'],args.owner[0],args.owner)):
         top_level = os.path.join(config['eos_prefix'],args.owner[0],args.owner)
      elif os.path.normpath(f.file).startswith(config['eos_project_prefix']):
         # check eligibility based on admin/writers egroup?
         print_json_error("NotImplemented")
         raise NotImplemented()
      else:
         msg="Cannot share outside of home and project directories"
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)         

   if args.cmd == "remove":
      # ... continue from common code above      

      shares=db.get_share(sharee=share_with_who,owner=args.owner,fid=f.fid)

      if len(shares)>1:
         msg="Multiple shares exist, share ids %s"%[s.id for s in shares]
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)

      if len(shares)==0:
         msg="Share from user %s to %s does not exist at path %s"%(args.owner,share_with_who,f.file)
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)
       
      #print 'would delete',shares[0].id
      db.delete_share(shares[0].id)

      try:
         # modify storage ACL      
         cernbox_utils.sharing.update_acls(f.fid,eos,db,args.owner)
      except Exception,x:
         logger.critical("Something went pretty wrong... %s %s",hash(x),x)
         print_json_error("Critical error %s"%hash(x))
         #rollback the insert?
         raise
         sys.exit(2)


   if args.cmd == "add":
      # ... continue from common code above

      ACL = {'r':'read','rw':'read-write'}
      ENTITY = {'u':'user','egroup':'egroup'}

      logger.info("Add %s share for %s %s to tree %s",ACL[args.acl],ENTITY[share_with_entity],share_with_who,args.path)

 
      # FIXME: do not use pound for this anymore (#): breaks HTTP standard and client browsers...
      file_target="/%s (#%d)" %(os.path.basename(os.path.normpath(f.file)),int(f.fid))

      # FIXME: poor's man solution: owncloud does not have constraints in the oc_share table
      # try to insert share entry, bailout if already exists...

      shares=db.get_share(sharee=share_with_who,owner=args.owner,fid=f.fid)

      if shares:
         msg="Share already exists, share id %d"%shares[0].id
         logger.error(msg)
         print_json_error(msg)
         sys.exit(2)
      else:
         db.insert_folder_share(args.owner,share_with_who,int(f.fid),file_target,0)

      try:
         # modify storage ACL      
         cernbox_utils.sharing.update_acls(f.fid,eos,db,args.owner,dryrun=False)
      except Exception,x:
         logger.critical("Something went pretty wrong... %s %s",hash(x),x)
         print_json_error("Critical error %s"%hash(x))
         #rollback the insert?
         raise
         sys.exit(2)


   if args.cmd == "show-other-acls":
      #from cernbox_utils import eos
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      other_acl_cnt = 0
      empty_acl_cnt = 0
      special_dir_cnt = 0
      cnt = 0

      for f in eos.fileinfo_r(args.path,type="-d"):

         cnt += 1
      
         if is_special_folder(f.file):
            special_dir_cnt+=1
            if args.ignore_special_directories:
               continue

         try:
            eos_acls = eos.parse_sysacl(f.xattr['sys.acl'])
         except KeyError,x:
            empty_acl_cnt+=1 # no ACL at all

         for acl in eos_acls:
            if acl.name != args.name:
               other_acl_cnt+=1
               logger.info("%s %s",f.file,eos_acls)
               break
            
      logger.info("Scan completed. Found %d directories, %d with acls not containing %s, %d with empty acls, %d special dirs",cnt,other_acl_cnt,args.name,empty_acl_cnt,special_dir_cnt)

   if args.cmd == "remove-orphan-xbits":
      #from cernbox_utils import eos
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      logfn = ""

      if args.logdir:
         import logging
         fix_str = ""
         if args.fix: fix_str=".fix"
         logfn = os.path.join(args.logdir,os.path.normpath(args.path).replace(os.sep,"_")+fix_str+".log")
         fh = logging.FileHandler(logfn)
         fh.setFormatter(logging.Formatter("%(asctime)s %(message)s"))
         logger.addHandler(fh)

      cnt = 0
      fixed_cnt = 0

      for f in eos.fileinfo_r(args.path,type="-d"):
         cnt += 1
         try:
            eos_acls = eos.parse_sysacl(f.xattr['sys.acl'])
         except KeyError,x:
            continue # no ACL at all

         new_acls = []
         for acl in eos_acls:
            if not acl.bits == "x":
               new_acls.append(acl)

         #logger.info(" --- SCAN      --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(eos_acls))

         if new_acls != eos_acls:
            logger.info(" --- NEW_ACL   --- %s --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(new_acls),eos.dump_sysacl(eos_acls))
            eos.set_sysacl(f.file,eos.dump_sysacl(new_acls),dryrun=not args.fix)
            fixed_cnt += 1
         else:
            #logger.info(" --- NO_CHANGE --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(eos_acls))
            pass

      logger.info("Scanned %d directories, fixed %d directories, logfile: %s",cnt,fixed_cnt,logfn)

#            print f.file, "would set", eos_acls, "->", new_acls
            #if len(new_acls)>1: print "MUTLIPLE"
#
#         else:
#            print f.file, "no change",eos_acls

   if args.cmd in ["list-shared-by","list-shared-with"]:

      from cernbox_utils import db,eos

      if not args.user.strip():
         logger.critical("Must provide a user name!")
         return

      db = db.ShareDB()
      eos = eos.EOS(config['eos_mgm_url'])
      eos.role=(0,0)

      if args.cmd == "list-shared-by":
         shares=db.get_share(owner=args.user)
      else:
         shares=db.get_share(sharee=args.user)   
   
      retobj = {}

      import datetime
      def dtisoformat(x):
         if x:
            return x.isoformat()
         else:
            return ""

      cnt=0
      for s in shares:
         logger.debug("Processing share: %s %s->%s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(str(s.file_target)))

         try:
            share_path = eos.fileinfo("inode:"+s.item_source).file
         except  subprocess.CalledProcessError,x:
            if x.returncode == 2:
               # eos entry does not exist
               logger.warning("DANGLING_SHARE id=%d owner=%s sharee=%s target='%s' inode=%s",s.id,s.uid_owner,s.share_with,s.file_target,s.item_source)
               share_path=None


         if share_path or args.include_broken:
            retobj[s.id] = {'share_id':s.id, 'share_with':s.share_with,'type':s.share_type,'target_inode':s.item_source,'target_name':s.file_target, 'permissions':s.permissions, 'created' : datetime.datetime.fromtimestamp(s.stime).isoformat(), 'expires' : dtisoformat(s.expiration), 'token':s.token, 'target_path':share_path }


      print_json({'shares':retobj})


   if args.cmd == "summary":

      from cernbox_utils import db,eos

      if not args.shares_owner.strip():
         logger.critical("Must provide a shares_owner or '-'")
         return

      if args.shares_owner == '-':
         args.shares_owner = ''


      db = db.ShareDB()

      shares=db.get_share(owner=args.shares_owner)

      owner_all_share_cnt = {}
      owner_link_share_cnt = {}
      owner_regular_share_cnt = {}

      for s in shares:
         try:
            if s.file_target is None:
               s.file_target = ''

            logger.debug("Processing share: %s %s->%s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(s.file_target))

            owner_all_share_cnt.setdefault(s.uid_owner,0)
            owner_link_share_cnt.setdefault(s.uid_owner,0)
            owner_regular_share_cnt.setdefault(s.uid_owner,0)

            owner_all_share_cnt[s.uid_owner] += 1

            if s.share_type == 3:
               owner_link_share_cnt[s.uid_owner] += 1
            else:
               owner_regular_share_cnt[s.uid_owner] += 1

         except Exception,x:
            logger.error("Problem with processing share id=%d : %s",s.id,repr(x))
            raise

      sort_by = owner_all_share_cnt


      if args.sort_by == 'regular':
         sort_by = owner_regular_share_cnt

      if args.sort_by == 'link':
         sort_by = owner_link_share_cnt

      index = len(owner_all_share_cnt)

      for u,cnt in sorted(sort_by.iteritems(), key=lambda (k,v): (v,k)):
         logger.info("Index #%4d Owner %10s has total of %4d shares: %4d regular shares, %4d link shares",index,u,owner_all_share_cnt[u],owner_regular_share_cnt[u],owner_link_share_cnt[u])
         index -= 1


   if args.cmd == "verify":

      import pwd

      if not args.shares_owner.strip():
         logger.critical("Must provide a shares_owner or '-'")
         return

      if args.shares_owner == '-':
         args.shares_owner = ''

      if args.deep_fs_check:
         if not args.shares_owner:
            logger.critical("Must provide a single shares_owner for --deep-fs-check option")
            return

      if args.logdir:
         import logging
         fix_str = ""
         if args.fix: fix_str=".fix"
         logfn = os.path.join(args.logdir,"verify."+args.shares_owner+fix_str+".log")
         fh = logging.FileHandler(logfn)
         fh.setFormatter(logging.Formatter("%(asctime)s %(message)s"))
         logger.addHandler(fh)


      db = db.ShareDB()

      shares=db.get_share(owner=args.shares_owner,share_type="regular")

      # for write ops
      eos_master = eos.EOS(config['eos_mgm_url'])
      eos_master.role=(0,0)

      # for read ops
      eos = eos.EOS(config['eos_slave_mgm_url'])
      eos.role=(0,0)

      # calculate complete acl list for each shared eos path (fid)
      # verify if shares are not outdated
   
      shared_fids = {}

      # shared_paths: key is a path with a trailing slash 
      shared_paths = {}
      shared_acls = {}

      # detect duplicate shares
      unique_share_keys = {}

      #parent_paths = {}

      disable_deep_check = False

      logger.info('Found %d shares of user %s',len(shares),args.shares_owner)

      for s in shares:
         fid = s.item_source

         logger.debug("Processing share: %s %s->%s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(s.file_target))

         # Verify if share points to a valid storage entity
         try:
            f=eos.fileinfo("inode:"+fid)

            if f.file.startswith(config['eos_recycle_dir']):
               # eos entry is in the trashbin
               logger.error("TRASHBIN_SHARE id=%d owner=%s sharee=%s target='%s' fid=%s",s.id,s.uid_owner,s.share_with,s.file_target,fid)
               logger.error("FIX: DELETE %s",s)
               if args.fix:
                  db.delete_share(s.id)
               continue
         except subprocess.CalledProcessError,x:
            if x.returncode == 2:
               # eos entry does not exist
               logger.error("DANGLING_SHARE id=%d owner=%s sharee=%s target='%s' fid=%s",s.id,s.uid_owner,s.share_with,s.file_target,fid)
               logger.error("FIX: DELETE %s",s)
               if args.fix:
                  db.delete_share(s.id)
               continue

         # share pointing outside of the home directories area
         # we do not validate these spaces later so we do not add these for subsequent verification
         if not os.path.normpath(f.file).startswith(config['eos_prefix']) and not os.path.normpath(f.file).startswith(config['eos_project_prefix']):
            logger.critical("OUTSIDE_SHARE share %s %s is outside of %s (%s)",s.id,s.file_target,config['eos_prefix'],f.file)
            #continue

         # NOT-AT-TOP-LEVELE SHARES ARE OK
         #if len(os.path.normpath(f.file).split("/"))>6:
         #   logger.error("NOT_AT_TOP_LEVEL_SHARE id=%d owner=%s sharee=%s target='%s' fid=%s actual_path=%s",s.id,s.uid_owner,s.share_with,s.file_target,fid,quote(f.file))
         #else:
 

         # Verify duplicate shares

         unique_key = (fid,s.share_with,s.uid_owner)

         try:
            existing_share = unique_share_keys[unique_key]
          
            perm1 = cernbox_utils.sharing.share2acl(existing_share).bits # older (shares are sorted by sid which grows in time)
            perm2 = cernbox_utils.sharing.share2acl(s).bits # newer (current)


            logger.error("DUPLICATE_SHARE older_share: id1 %s perm1 %s stime1 %s; newer_share: id2 %d perm2 %s stime2 %s (owner=%s sharee=%s target='%s' fid=%s)",existing_share.id,perm1,existing_share.stime,s.id,perm2,s.stime,s.uid_owner,s.share_with,s.file_target,fid)

            assert(perm1 in ['rx','rwx+d']) #we don't understand other permissions
            assert(perm2 in ['rx','rwx+d']) #we don't understand other permissions

            # here there may be multiple strategies how to fix duplicates

            # exact duplicates are safe to remove
            if perm1 == perm2:
               logger.error("FIX: exact duplicates, will delete older share: %s",existing_share.id)
               if args.fix:
                  db.delete_share(existing_share.id)
                  unique_share_keys[unique_key] = s                  
            else:
               logger.error("duplicate share with different permissions, delete manually one of: %s %s",existing_share.id,s.id)
               disable_deep_check = True

            continue

            # keep the share with stronger permissions or prefer a newer one
            #if perm2 == 'rwx+d' or (perm2 == perm1 == 'rx'):
            #   logger.error("FIX1: (older) DELETE %s",existing_share)
            #   if args.fix:
            #      db.delete_share(existing_share.id)
            #   unique_share_keys[unique_key] = s
            #else:
            #   logger.error("FIX1:  (weaker) DELETE %s",s)
            #   if args.fix:
            #      db.delete_share(s.id)


            # check the actual ACL on eos (if exists) and stick to this one
            # eos_acls = eos.parse_sysacl(f.xattr['sys.acl'])

         except KeyError:
            unique_share_keys[unique_key] = s

         if s.file_target.count("/")>1:
            logger.error("FILE_TARGET_MULTIPLE_SLASH_PROBLEM id=%d owner=%s sharee=%s target='%s' fid=%s stime=%s",s.id,s.uid_owner,s.share_with,s.file_target,fid,s.stime)
            fixed_target='/%s'%os.path.basename(s.file_target)
            assert("'" not in fixed_target)
            logger.error("FIX: update target to '%s'",fixed_target)
            if args.fix:
               db.update_share(s.id,file_target=fixed_target)
            continue

         #if not s.file_target.startswith("/") or s.file_target.count("/")>1:

         # check if owner still exists, if not issue error but treat the share normally
         # otherwise this is dangerous if local password database is not fully synchronized with ldap!
         try:
            pwd.getpwnam(s.uid_owner)
         except:
            logger.error("USER_NOT_FOUND: share owner uid %s does not exist",s.uid_owner)
            continue

         logger.info("VALID_SHARE: share_id=%s %s->%s %s %s %s",s.id,s.uid_owner,s.share_with,s.item_source,quote(s.file_target),quote(f.file))
         
         # this is the expected ACL entry in the shared directory tree
         acl = cernbox_utils.sharing.share2acl(s)

         shared_fids.setdefault(fid,[]).append(acl)

         p = os.path.normpath(f.file)+"/" # append trailing slash, otherwise directories which basename is a substring give false positive, e.g.: /eos/user/k/kuba/tmp.readonly /eos/user/k/kuba/tmp
         shared_paths[p] = fid
         shared_acls.setdefault(p,[]).append(acl)
         

      logger.info("Expected shared paths with visibility to others (%s)",len(shared_acls))
      for p,acl in shared_acls.items():
         logger.info("Expected acls in shared path %s %s",p,eos.dump_sysacl(acl))

      blacklist_paths=[]
      # BLACKLIST FUNCTIONALITY
      logger.info("Blacklisted trees (%s) which will not be analysed but are problematic",len(blacklist_paths))
      for p in blacklist_paths:
         logger.error("Blacklisted %s",p)

         
      # scan full tree

      if args.deep_fs_check:

         if disable_deep_check:
            logger.fatal("deep check disabled by previous errors")
            return

         if args.homedir:
            homedir = args.homedir
         else:
           homedir = os.path.join(config['eos_prefix'],args.shares_owner[0],args.shares_owner)
            #homedir = '/eos/project/c/cmsgem-ge11-production'
            #homedir = '/eos/project/a/atlasweb'


         cnt = 0
         cnt_fix = 0
         cnt_safe_fix = 0
         cnt_unsafe_fix = 0
         cnt_wrong_bits = 0
         cnt_skipped = 0

         cnt_fix_plaindir = 0

         for f in eos.fileinfo_r(homedir,type="-d"):
            cnt += 1
            try:
               eos_acls = eos.parse_sysacl(f.xattr['sys.acl'])

               # in the rest of this algorithm below we assume that ACL bits belong to a known set
               # modify with care...
               ALLOWED_ACLS = ['rx','rwx+d','rwx!m']

               def check_allowed():
                  for a in eos_acls:
                     if not a.bits in ALLOWED_ACLS:
                        logger.fatal("ACL bits not allowed: %s %s %s",a, f.file, eos.dump_sysacl(eos_acls))
                        return False
                  return True

               if not check_allowed():
                  cnt_wrong_bits += 1
                  cnt_skipped += 1
                  continue

               if is_special_folder(f.file):
                  logger.error("Special folder should not have sys.acl set: %s",f.file)
                  # FIXME: remove ACL from special folder?
            except KeyError,x:
               if is_special_folder(f.file):
                  continue # skip this entry, it is okey for special folders not to have ACL at all
               else:
                  eos_acls = [] # no ACLs defined for this directory


            # FIX: u:wwweos:rx

            # BLACKLIST FUNCTIONALITY
            # do not touch anything in blacklisted paths: we may not know what to do with them (yet)
            def is_blacklisted(path):
               for black_p in blacklist_paths:
                  if f.file.startswith(black_p):
                     return True
               return False

            if is_blacklisted(f.file):
               cnt_skipped += 1
               continue

            # expected ACL
            expected_acls = [eos.AclEntry(entity="u",name=args.shares_owner,bits="rwx!m")] # this acl entry should be always set for every directory in homedir
            p = os.path.normpath(f.file)
            
            assert(f.is_dir())
            
            p += "/" # add trailing slash to directories, this will make sure that the top-of-shared-directory-tree also matches 

            shared_directory = False # indicate if the current directory is shared

            for sp in shared_paths:
               if p.startswith(sp): # directory is part of a share tree which has a top at sp
                  expected_acls.extend(shared_acls[sp])
                  shared_directory = True

            expected_acls = cernbox_utils.sharing.squash(set(expected_acls))

            logger.debug(" --- SCAN      --- %s --- %s --- %s",f.fid, f.file, eos.dump_sysacl(eos_acls))

            dryrun = not args.fix

            actions = []
            safe_fix = None # determines if it is "safe" to fix the ACLs (not taking away existing permissions)

            if set(eos_acls) < set(expected_acls):
               actions.append(("ADD",set(expected_acls)-set(eos_acls)))
               safe_fix = True
            elif set(eos_acls) > set(expected_acls):
               actions.append(("REMOVE",set(eos_acls)-set(expected_acls)))
               safe_fix = False
            elif set(eos_acls) != set(expected_acls):
                  if not args.fix_all_perms:
                     dryrun = True # do not fix anything like that (unless explicitly specified: --fix-all-perms)

                  safe_fix = False

                  # let's be a bit more specific about the differences

                  added_acls = set(expected_acls)-set(eos_acls)
                  removed_acls = set(eos_acls)-set(expected_acls)

                  updated_acls = set()

                  def find_acl_by_entity_name(entity,name,acl_list):
                     for a in acl_list:
                        if a.entity == entity and a.name == name:
                           return a
                     return None

                  for acl1 in removed_acls.copy(): # we may remove from removed_acls set as we iterate over it

                     acl2 = find_acl_by_entity_name(acl1.entity,acl1.name,added_acls)

                     if acl2:

                        if 'rx' in acl1.bits:
                           safe_fix = True

                        updated_acls.add(eos.AclEntry(entity=acl1.entity,name=acl1.name,bits=acl1.bits+"->"+acl2.bits))
                        removed_acls.remove(acl1)
                        added_acls.remove(acl2)


                  if added_acls:
                     actions.append(("ADD",added_acls))
                  if removed_acls:
                     actions.append(("REMOVE",removed_acls))
                  if updated_acls:
                     actions.append(("UPDATE",updated_acls))
                  
            if actions:

               cnt_fix += 1

               if not shared_directory:
                  cnt_fix_plaindir += 1

               if safe_fix:
                  msg = "_SAFE"
                  cnt_safe_fix +=1
               else:
                  msg = ""
                  cnt_unsafe_fix +=1

               logger.error("FIX_ACL%s: %s '%s' %s", msg, f.fid, f.file, " ".join([a[0]+" "+eos.dump_sysacl(a[1]) for a in actions]))

               eos_master.set_sysacl(f.file,eos.dump_sysacl(expected_acls),dryrun=dryrun)

            else:
               pass

         logger.critical("Overview for user %s : scanned %d directories, safe fix: %d unsafe fix: %d plaindir fix: %d skipped: %d wrong bits: %d",args.shares_owner,cnt,cnt_safe_fix,cnt_unsafe_fix,cnt_fix_plaindir,cnt_skipped,cnt_wrong_bits)
            
      return 

      # compare the acl list calculated from share db with the actual acl list on eos in the shared directory tree
 
      for fid in shared_fids:

         f=eos.fileinfo("inode:"+fid)

         db_acls = set(shared_fids[fid])

         # add the ACL for the owner
         try:
            owner = pwd.getpwuid(int(f.uid)).pw_name
         except KeyError,x:
            logger.error("USER_NOT_FOUND: file owner uid %s does not exist, skipping... %s",f.uid,f.file)
            continue

         db_acls.add(eos.AclEntry(entity='u',name=owner,bits='rwx!m'))

         # here we recursively check if the same set of db_acls is consistenly applied in the whole tree
         # the first entry reported is the shared directory itself (the top level of the tree)
         # we will need maybe to prune bottom paths to avoid too many error messages for large trees
         for f in eos.fileinfo_r(f.file,type="-d"):
            if not is_special_folder(f.file):
               logger.debug("checking shared tree: %s",str(f.file))
               eos_acls = set(eos.parse_sysacl(f.xattr['sys.acl']))

               extra_acls = eos_acls-db_acls
               if extra_acls:
                  logger.warning("EXTRA_ACL path '%s': %s owner: %s ACTUAL %s EXPECTED %s",f.file,eos.dump_sysacl(cernbox_utils.sharing.squash(extra_acls)),owner,f.xattr['sys.acl'], eos.dump_sysacl(cernbox_utils.sharing.squash(db_acls)))

               missing_acls = db_acls-eos_acls
               if missing_acls:
                  logger.error("MISSING_ACL path '%s': %s owner: %s ACTUAL %s EXPECTED %s",f.file,missing_acls,owner,f.xattr['sys.acl'], eos.dump_sysacl(cernbox_utils.sharing.squash(db_acls)))
                  break
      logger.info('verified %d shares and %d eos paths'%(len(shares),len(shared_fids)))
   logger.info("OK")

def is_special_folder(path):
   "Special system directories are hidden and used to implement certain features such as atomic upload, versioning: .sys.v# .sys.a#"
   name = os.path.basename(os.path.normpath(path))
   for prefix in ['.sys.v#','.sys.a#']:
      if name.startswith(prefix):
         return True
   return False


def more_permissions_than(acl_list, reference_acl_list):
   """Return all ACL entries from acl_list which give more permissions than specified by reference_acl_list.
   """

   acls=set(acl_list)
   refs=set(reference_acl_list)

   more = set()

   for acl in acls:
      if not acl in refs:
         pass
   
def parse_sharee(sharee):
    try:
       entity,who = sharee.split(":") # this may also raise ValueError
       if not entity in ['u','egroup']:
          raise ValueError()
    except ValueError:
       print >> sys.stderr, "ERROR: specify sharee '%s' in u:USER or egroup:GROUP format"%sharee
       sys.exit(2)
    return entity,who

def parse_path(path):
    if not path.startswith(config['eos_prefix']):
       print >> sys.stderr, "ERROR: path '%s' should start with '%s'"% (path,config['eos_prefix'])
       sys.exit(2)
    return path

if __name__ == "__main__":
   sys.exit(main())
